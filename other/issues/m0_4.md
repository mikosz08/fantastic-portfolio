# M0‑4

**Milestone:** M0 — Scaffold & MVP Endpoints
**Labels:** `type:feature`, `area:api`, `priority:P1`, `env:dev`

---

## Description

Implement `POST /events` for telemetry ingestion with **idempotency** enforced by the `Idempotency-Key` header. First submission should store the event and return **202 Accepted**; **replays** (same key) must return **200 OK** without creating a duplicate, echoing the original record. Target runtime: **.NET 9.0** with EF Core + Postgres.

**Definition of Done**

* Request model validated, key extracted reliably (header or body fallback).
* Write path enforces uniqueness on `IdempotencyKey` and handles conflict as success (no duplicate).
* Response includes the stored event (id, occurredAt, type, seed fields if present, etc.).
* Unit tests cover happy path + duplicate path.

---

## API Contract (minimal)

**Route:** `POST /events`
**Headers:** `Idempotency-Key: <uuid-or-string>` (required)
**Body (example):**

```json
{
  "type": "item_collected",
  "playerId": "p-123",
  "sessionId": "s-456",
  "occurredAt": "2025-09-18T12:34:56Z",
  "payload": { "item": "coin", "value": 5 }
}
```

**Responses:**

* `202 Accepted` — first insert; body returns the stored event.
* `200 OK` — duplicate idempotency key; body returns the original stored event.
* `400 Bad Request` — missing/invalid `Idempotency-Key` or payload.

---

## Tasks

1. **DTOs & validation**

   * Add `EventCreateDto` with required fields (`type`, `occurredAt`, optional `playerId`, `sessionId`, `payload`).
   * FluentValidation or minimal manual checks (keep lightweight for M0).
2. **Header extractor / middleware**

   * Implement a small binder/middleware to read `Idempotency-Key` (case-insensitive) and attach to `HttpContext.Items` or pass to handler.
3. **Endpoint/handler**

   * Minimal API or controller action `POST /events`.
   * Call repository `InsertIdempotentAsync(dto, key)` that implements conflict-as-success.
4. **Repository behavior**

   * Try insert (EF Core). On `DbUpdateException` caused by unique key, **fetch and return** the existing row.
   * Persist fields: `Id` (Guid), `OccurredAt`, `Type`, `PlayerId?`, `SessionId?`, `IdempotencyKey`, `Payload (jsonb)`, `IngestedAt (now())`.
5. **Mapping & response**

   * Map entity → `EventReadDto` and return with proper status code (202 on create, 200 on replay).
6. **Unit tests (xUnit/NUnit)** under `tests/unit/` (or `tests/integration/` if easier):

   * `PostEvents_Creates_OnFirstCall_Returns202`
   * `PostEvents_ReplaySameKey_NoDuplicate_Returns200`
   * Optional: missing header ⇒ 400.
7. **README** — add curl examples to Evidence Index snippet.

---

## Acceptance Criteria

* Posting with a **new** `Idempotency-Key` persists exactly **one** row and returns **202** with the stored document.
* Posting again with the **same** key returns **200** and **does not** create a second row (verified via query/count or test assertion).
* Unit tests for the two paths pass locally.
* Evidence added: request/response examples and test outputs.

---

## Evidence

* `src/App/Endpoints/Events.cs` (or controller), `src/App/Data/*` updates
* `tests/unit/EventsTests.cs` (or `tests/integration/EventsTests.cs`)
* README curl examples

---

## Risks & Mitigations

* **Header missing/typo** → Enforce presence and document proper casing; support body fallback `idempotencyKey` (optional).
* **Race conditions** → Rely on DB unique constraint; catch conflict and return existing.
* **Payload size** → Keep payload as JSON; consider max size in Kestrel later.

---

## Hint Ladder

* **Hint 1:** Use `Request.Headers["Idempotency-Key"]` and guard against multiple values; trim whitespace.
* **Hint 2:** For EF Core conflict handling with Npgsql, inspect `PostgresException.SqlState == "23505"` (unique\_violation) to branch into the fetch‑existing path.
* **Reveal (on request):** Full code for DTOs, endpoint (Minimal API), repository method with conflict‑as‑success, and unit tests with an in‑memory or Testcontainers Postgres.

