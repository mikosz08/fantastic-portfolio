# M0‑4‑1

**Milestone:** M0 — Scaffold & MVP Endpoints
**Labels:** `type:feature`, `area:api`, `area:validation`, `priority:P1`

---

## Mini‑lesson (why these choices)

* **DTO vs Entity:** DTO is the HTTP contract — stable, minimal, independent from EF entity. Keeps API changes decoupled from schema.
* **`sealed` DTO classes:** We don’t intend inheritance; sealing allows JIT devirtualization and prevents unintended subclassing.
* **`required` + `init`:** With System.Text.Json in .NET 9, `required` ensures deserializer sets the property; `init` keeps DTOs immutable after creation.
* **`DateTimeOffset` > `DateTime`:** Preserves absolute time across zones. Telemetry timestamps must be unambiguous.
* **`JsonElement` for `payload`:** Efficient for pass‑through JSON; we validate shape later if needed. Maps easily to `jsonb` via string in entity.
* **Validation strategy:** Start lightweight: guard clauses in handler (M0). Optionally add FluentValidation at M1 when rules grow.

---

## Description

Introduce request/response DTOs for `POST /events` and minimal validation. Provide a small helper to read `Idempotency-Key` header and a consistent error shape (`ProblemDetails`). No persistence logic here — this issue is purely about the HTTP contract and validation.

**Definition of Done**

* DTOs exist under `src/App/Contracts/` and are used by the endpoint.
* Basic validation covers `type`, `occurredAt`, and header `Idempotency-Key` presence.
* Standardized `ProblemDetails` returned for 400s.

---

## Tasks

1. **Create request DTO** `src/App/Contracts/EventCreateDto.cs`

   ```csharp
   using System.Text.Json;

   namespace App.Contracts;

   // Sealed: no inheritance; init-only: immutable after binding
   public sealed class EventCreateDto
   {
       public required string Type { get; init; }
       public required DateTimeOffset OccurredAt { get; init; }
       public string? PlayerId { get; init; }
       public string? SessionId { get; init; }
       public JsonElement? Payload { get; init; } // optional arbitrary JSON
   }
   ```

2. **Create response DTO** `src/App/Contracts/EventReadDto.cs`

   ```csharp
   using System.Text.Json;

   namespace App.Contracts;

   public sealed class EventReadDto
   {
       public required Guid Id { get; init; }
       public required string Type { get; init; }
       public required DateTimeOffset OccurredAt { get; init; }
       public string? PlayerId { get; init; }
       public string? SessionId { get; init; }
       public JsonElement? Payload { get; init; }
       public required DateTimeOffset IngestedAt { get; init; }
   }
   ```

3. **Header extraction helper** `src/App/Http/IdempotencyKey.cs`

   ```csharp
   namespace App.Http;

   public static class IdempotencyKey
   {
       public const string HeaderName = "Idempotency-Key";

       public static bool TryGet(HttpRequest req, out string key)
       {
           if (req.Headers.TryGetValue(HeaderName, out var values))
           {
               key = values.Count > 0 ? values[0].ToString().Trim() : string.Empty;
               if (!string.IsNullOrWhiteSpace(key)) return true;
           }
           key = string.Empty;
           return false;
       }
   }
   ```

4. **ProblemDetails factory** (uniform 400s) `src/App/Http/ProblemFactory.cs`

   ```csharp
   using Microsoft.AspNetCore.Mvc;

   namespace App.Http;

   public static class ProblemFactory
   {
       public static IResult BadRequest(string title, IDictionary<string, string[]>? errors = null)
       {
           var pd = new ValidationProblemDetails(errors ?? new Dictionary<string, string[]>())
           {
               Title = title,
               Status = StatusCodes.Status400BadRequest
           };
           return Results.Problem(pd);
       }
   }
   ```

5. **Wire minimal validation into endpoint** (temporary location; final handler comes in M0‑4‑2)

   * In `Program.cs` (or `Endpoints/Events.cs`), add a minimal stub to validate before calling the repository (next issue will add persistence):

   ```csharp
   using App.Contracts;
   using App.Http;

   app.MapPost("/events", (HttpRequest req, EventCreateDto dto) =>
   {
       if (!IdempotencyKey.TryGet(req, out var key))
           return ProblemFactory.BadRequest("Missing Idempotency-Key header");

       var errors = new Dictionary<string, string[]>();
       if (string.IsNullOrWhiteSpace(dto.Type))
           errors[nameof(dto.Type)] = new[] { "Type is required." };
       if (dto.OccurredAt == default)
           errors[nameof(dto.OccurredAt)] = new[] { "OccurredAt must be a valid timestamp." };

       if (errors.Count > 0)
           return ProblemFactory.BadRequest("Validation failed", errors);

       // TEMP response for M0-4-1: echo input (id/ingestedAt will be set in M0-4-2)
       return Results.Accepted(
           uri: null,
           value: new { request = dto, idempotencyKey = key }
       );
   })
   .WithName("PostEvents")
   .ProducesValidationProblem();
   ```

6. **Unit tests (happy path + validation)** `tests/unit/EventDtoValidationTests.cs`

   * Missing header ⇒ 400 with `ProblemDetails`.
   * Missing `type` ⇒ 400.
   * `occurredAt` default ⇒ 400.
   * Valid request ⇒ **202 Accepted** (temporary behavior until M0‑4‑2).

7. **README update**

   * Add a tiny section showing a `curl` with `Idempotency-Key` and a valid body; note that persistence is added in M0‑4‑2.

---

## Acceptance Criteria

* Calls to `POST /events` without `Idempotency-Key` or required fields return **400** with `ProblemDetails` payload.
* Calls with valid header/body return **202 Accepted** and echo the request (temporary).
* DTOs are `sealed`, use `required` where applicable, and compile on .NET 9.
* Unit tests pass locally.

---

## Evidence

* `src/App/Contracts/EventCreateDto.cs`, `EventReadDto.cs`
* `src/App/Http/IdempotencyKey.cs`, `ProblemFactory.cs`
* Endpoint stub in `Program.cs` or `Endpoints/Events.cs`
* `tests/unit/EventDtoValidationTests.cs`
* README curl example

---

## Risks & Mitigations

* **Premature complexity in validation:** Start with guard clauses; switch to FluentValidation at M1 when rules harden.
* **Time skew issues:** Use `DateTimeOffset` from client; server uses UTC internally.
* **Payload shape drift:** Keep `JsonElement` loose for now; enforce schema by event type in later milestones.

---

## Hint Ladder

* **Hint 1:** Prefer properties with `required` over primary‑constructor records; validation attributes and `required` play nicer with JSON binding.
* **Hint 2:** Use `.ProducesValidationProblem()` to document 400s in Swagger; add `.WithOpenApi()` for discoverability.
* **Reveal (on request):** I’ll provide a ready‑to‑paste endpoint class with full mapping to entity + unit tests (xUnit) and a test request builder.

