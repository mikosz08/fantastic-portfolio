# M0‑4‑3 — Persistence & idempotent repository for `POST /events`

**Milestone:** M0 — Scaffold & MVP Endpoints
**Labels:** `type:feature`, `area:api`, `area:data`, `priority:P1`, `env:dev`

---

## Mini‑lesson — where idempotency really lives

* The **HTTP layer** (DTOs, filters) checks that an idempotency key was sent and has the right shape.
* The **database** enforces the rule "no duplicates" via a **unique index** on `IdempotencyKey`.
* The **repository/service** glues this together: it tries to insert, catches the **unique violation**, and returns the **original** record instead of failing.
* This pattern is often called **conflict‑as‑success**: the first writer does real work, others just get the result.

---

## Description

Wire the `/events` endpoint to real persistence using EF Core and Postgres. Implement a small repository/service that:

* Inserts a new event on first use of an `IdempotencyKey`.
* On duplicate key, loads and returns the existing row.
* Allows the API to decide between **202 (created)** and **200 (replayed)**.

This issue focuses on **domain + data layer** behavior and endpoint wiring, not on exhaustive validation (that’s in M0‑4‑1/2).

**Definition of Done**

* A repository/service exists for `events` with a single idempotent write operation.
* `/events` calls that service and returns 202 on first insert, 200 on replay.
* Tests prove there is **exactly one row** per idempotency key.

---

## Tasks

> High level on purpose; implementation details (namespaces, exact signatures) zostawiamy na Development.

1. **Define a repository/service contract**

   * Add a small interface under e.g. `src/App/Application/Events/IEventsService.cs` or `.../IEventsRepository.cs`.
   * One main method, e.g.:

     * Input: `EventCreateDto` + `idempotencyKey` + optional `CancellationToken`.
     * Output: something like `(EventReadDto eventDto, bool isReplay)` or a small result type.
   * Goal: handler doesn’t know about EF, Postgres, exception types.

2. **Implement the repository using EF Core**

   * Place concrete implementation in `src/App/Infrastructure/Events/EventsService.cs` (or similar folder structure: `Application` vs `Infrastructure`).
   * Use the existing `AppDbContext` and `Event` entity.
   * Behavior:

     * Map DTO → entity.
     * Try to **add + save**.
     * If save succeeds → mark `isReplay = false`.
     * If a DB unique‑key exception is thrown for `IdempotencyKey`:

       * Roll back the insert.
       * Load the existing row by `IdempotencyKey`.
       * Map to `EventReadDto` and return `isReplay = true`.
   * Keep retry/transaction logic simple for M0.

3. **Map entity ↔ DTOs**

   * Introduce a small mapping helper (static class or extension methods) in e.g. `src/App/Application/Events/EventMappings.cs`.
   * Responsibilities:

     * `EventCreateDto` → `Event` (including setting `Id`, `IngestedAt`, `IdempotencyKey`, `Payload`).
     * `Event` → `EventReadDto`.
   * Decide how `Payload` is stored in the entity (string vs JSON type) and convert accordingly.

4. **Register the service in DI**

   * In `Program.cs` (or composition root), register the repository/service as a scoped dependency.
   * Example shape (pseudocode):

     * `builder.Services.AddScoped<IEventsService, EventsService>();`

5. **Wire `/events` endpoint to the service**

   * Update the handler created in M0‑4‑1/2 so it:

     * Accepts `EventCreateDto` and `idempotencyKey`.
     * Calls `IEventsService`.
     * Uses the returned `isReplay` flag to choose status code:

       * `202 Accepted` when `isReplay == false`.
       * `200 OK` when `isReplay == true`.
     * Always returns `EventReadDto` (not the raw entity).

6. **Add tests for idempotent behavior**

   * Create tests under e.g. `tests/integration/EventsPersistenceTests.cs` or `tests/unit/EventsServiceTests.cs`.
   * Cover at least:

     * First call with a new `IdempotencyKey`:

       * Exactly **one** row in `events`.
       * `isReplay == false` and API responds with 202.
     * Second call with the same `IdempotencyKey` and same body:

       * Still **one** row in `events`.
       * `isReplay == true` and API responds with 200.
     * Optional: different body with same `IdempotencyKey` → still original row is returned (document behavior).
   * Decide whether to use real Postgres (Testcontainers/Compose) or an in‑memory setup for M0.

7. **Evidence & docs**

   * Add request/response examples for first call vs replay to README or a short design doc under `docs/`.
   * Update Evidence Index in README with:

     * Path to the new service.
     * Path to tests.
     * Link to a PR showing green tests for M0‑4‑3.

---

## Acceptance Criteria

* Calling `POST /events` twice with the **same** `Idempotency-Key` results in:

  * API responses: first **202**, second **200**.
  * Database: exactly **one** row present for that key.
* Repository/service interface has a single, clear idempotent write method used by the endpoint.
* Mapping code ensures that `EventReadDto` contains `Id`, `Type`, `OccurredAt`, optional identifiers, `Payload`, and `IngestedAt`.
* Tests proving idempotent behavior pass locally and in CI.

---

## Evidence

* `src/App/Application/Events/IEventsService.cs` (or similar contract)
* `src/App/Infrastructure/Events/EventsService.cs` (implementation)
* Mapping helpers (e.g., `EventMappings.cs`)
* Updated `/events` endpoint handler
* Tests under `tests/...` for first‑call vs replay behavior
* README/docs updates with curl examples

---

## Risks & Mitigations

* **Leaking DB exceptions to API layer** → handle unique constraint in repository, return clean result type instead of throwing.
* **Race conditions on inserts** → rely on DB unique index; we don’t implement distributed locks at M0.
* **Changing payload shape** → document that idempotency is keyed only on header, not on body contents (clients must respect this contract).

---

## Hint Ladder

* **Hint 1:** Start with the repository method signature and tests; let that drive the implementation (TDD‑style). The endpoint then becomes a thin adapter.
* **Hint 2:** For the conflict‑as‑success path, centralize the unique‑violation check in one helper so you don’t scatter DB‑specific code.
* **Reveal (on request):** I can provide a concrete `EventsService` implementation with EF Core + Npgsql, including code to detect Postgres `23505` and an example integration test using a real Postgres container.

