# M0‑3

**Milestone:** M0 — Scaffold & MVP Endpoints
**Labels:** `type:feature`, `area:data`, `priority:P1`, `env:dev`

---

## Description

Introduce the **append‑only `events`** data model and wire up **EF Core** with **PostgreSQL**. Add the DB service to `compose.yaml`, configure a safe connection string via env vars, and create the **initial migration**. This unblocks `/events` idempotent ingestion and `/readyz` checks in later issues.

**Definition of Done**

* `Event` entity and `AppDbContext` exist with a unique **`idempotency_key`** constraint.
* Postgres runs via Compose; the app can connect using env‑provided connection string.
* Initial migration is created and applied successfully.

---

## Tasks

1. **Add EF Core packages** to `src/App/App.csproj`:

   * `Microsoft.EntityFrameworkCore` (9.x)
   * `Npgsql.EntityFrameworkCore.PostgreSQL` (9.x)
   * (dev) `Microsoft.EntityFrameworkCore.Design` (PrivateAssets=All)

2. **Create data model & DbContext** under `src/App/Data/`:

   * `Event` with fields (suggested):

     * `Id` (Guid), `OccurredAt` (DateTimeOffset), `Type` (string),
       `PlayerId` (string?), `SessionId` (string?), `IdempotencyKey` (string),
       `Payload` (JsonDocument or string), `IngestedAt` (DateTimeOffset, default now).
   * `AppDbContext` with `DbSet<Event>` and `OnModelCreating` to set:

     * Table `events` (snake\_case),
     * Unique index on `IdempotencyKey`,
     * Required columns & reasonable lengths.

3. **Configure Postgres connection** in `Program.cs`:

   * Read from `ConnectionStrings__Default` env var (12‑factor friendly).
   * `builder.Services.AddDbContext<AppDbContext>(o => o.UseNpgsql(cs));`

4. **Extend Compose with Postgres** (edit `compose.yaml`):

   ```yaml
   services:
     db:
       image: postgres:16-alpine
       environment:
         POSTGRES_USER: app
         POSTGRES_PASSWORD: app
         POSTGRES_DB: gameops
       volumes:
         - dbdata:/var/lib/postgresql/data
       healthcheck:
         test: ["CMD-SHELL", "pg_isready -U app -d gameops"]
         interval: 5s
         timeout: 3s
         retries: 10
     app:
       build:
         context: .
         dockerfile: ops/Dockerfile
       environment:
         ASPNETCORE_URLS: http://+:8080
         ConnectionStrings__Default: Host=db;Username=app;Password=app;Database=gameops
       depends_on:
         db:
           condition: service_healthy
       ports:
         - "8080:8080"
   volumes:
     dbdata:
   ```

5. **Add migration & update DB** (dev flow):

   * Add local tool manifest and EF CLI:

     ```bash
     dotnet new tool-manifest
     dotnet tool install dotnet-ef
     ```
   * Create the initial migration (from repo root):

     ```bash
     dotnet ef migrations add Init --project src/App --startup-project src/App
     ```
   * Apply it (two options):

     * **Via CLI** (requires the DB up):

       ```bash
       docker compose up -d db
       dotnet ef database update --project src/App --startup-project src/App
       ```
     * **On app start (dev only):** call `context.Database.Migrate()` at startup (guard with `if (env.IsDevelopment())`).

6. **README update**:

   * Add a **Database** section (how to start Postgres via Compose, how to run migrations, how to reset volume).
   * Add entries to **Evidence Index** (migration name, compose change).

7. (Optional) **CI check** for migrations:

   * Add a step to `ci.yml` that runs `dotnet ef migrations script --idempotent` to ensure migrations compile.

---

## Acceptance Criteria

* `compose.yaml` includes a healthy **Postgres 16** service + persistent volume; `docker compose up -d` starts both **db** and **app**.
* App logs show successful DB connection on startup (no migration errors).
* `dotnet ef migrations add Init` produces files under `src/App/Migrations/*`.
* `dotnet ef database update` (or dev‑time `Migrate()`) applies the schema, including a **unique index** on `idempotency_key`.

---

## Evidence

* `src/App/Data/Event.cs`, `src/App/Data/AppDbContext.cs`
* `src/App/Migrations/2025xxxxxx_Init.*`
* `compose.yaml` diff adding `db` service + volume
* README section "Database & Migrations"

---

## Risks & Mitigations

* **Flaky startup ordering (app before DB):** `depends_on` with healthcheck; retry policy on DB context (future).
* **Accidental secrets in repo:** only use **dev** credentials in Compose; keep prod creds out of Git.
* **Model drift:** migrations as the single source of truth; idempotency enforced via **unique index**.

---

## Hint Ladder

* **Hint 1:** Use `JsonDocument` or `JsonElement` for `Payload` to avoid early schema lock‑in.
* **Hint 2:** Map snake\_case via `ToTable("events")` and `Property(e => e.IdempotencyKey).HasColumnName("idempotency_key")` for consistency with SQL.

